
import { useState, useEffect, useRef, useCallback } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import { toast } from 'sonner';
import apiClient, { SegmentationPolygon } from '@/lib/api';
import { SegmentationResult, Polygon } from '@/lib/segmentation';
import { sortImagesBySettings } from '@/hooks/useImageFilter';
import type { ProjectImage } from '@/types';

/**
 * Základní hook pro segmentační editor - práce s daty
 */
export const useSegmentationCore = (
  projectId: string | undefined,
  imageId: string | undefined,
  userId: string | undefined,
  onImageChange?: () => void
) => {
  const params = useParams<{ projectId: string; imageId: string }>();
  const navigate = useNavigate();
  
  // Pokud není poskytnut projectId/imageId, zkusíme je získat z URL
  const finalProjectId = projectId || params.projectId;
  const finalImageId = imageId || params.imageId;
  
  // Stav pro segmentační editor
  const [projectTitle, setProjectTitle] = useState<string>('');
  const [imageName, setImageName] = useState<string>('');
  const [imageSrc, setImageSrc] = useState<string>('');
  const [segmentation, setSegmentation] = useState<SegmentationResult | null>(null);
  const [loading, setLoading] = useState<boolean>(true);
  const [saving, setSaving] = useState<boolean>(false);
  const [projectImages, setProjectImages] = useState<ProjectImage[]>([]);
  const [imageDimensions, setImageDimensions] = useState<{ width: number, height: number } | null>(null);
  
  // Reference na kontejner canvasu
  const canvasContainerRef = useRef<HTMLDivElement | null>(null);
  
  // Fetch project data
  useEffect(() => {
    const fetchProjectData = async () => {
      if (!finalProjectId) return;
      
      try {
        const project = await apiClient.getProject(finalProjectId);
        setProjectTitle(project.name);
      } catch (error) {
        console.error('Error fetching project:', error);
        toast.error('Nepodařilo se načíst data projektu');
      }
    };
    
    fetchProjectData();
  }, [finalProjectId]);
  
  // Fetch all images in the project
  useEffect(() => {
    const fetchProjectImages = async () => {
      if (!finalProjectId) return;
      
      try {
        const response = await apiClient.getProjectImages(finalProjectId);
        
        // Transform to ProjectImage format
        const formattedImages: ProjectImage[] = response.images.map(img => ({
          id: img.id,
          name: img.name,
          url: img.image_url,
          thumbnail_url: img.thumbnail_url,
          createdAt: new Date(img.created_at),
          updatedAt: new Date(img.updated_at),
          segmentationStatus: img.segmentation_status,
          project_id: img.project_id,
          image_url: img.image_url
        }));
        
        // Sort images according to stored filter settings to maintain consistency with project view
        const sortedImages = sortImagesBySettings(formattedImages);
        setProjectImages(sortedImages);
      } catch (error) {
        console.error('Error fetching project images:', error);
      }
    };
    
    fetchProjectImages();
  }, [finalProjectId]);
  
  
  // Fetch image and segmentation data
  useEffect(() => {
    const fetchData = async () => {
      if (!finalProjectId || !finalImageId) {
        setLoading(false);
        return;
      }
      
      // Reset polygon states when image changes
      onImageChange?.();
      
      setLoading(true);
      
      try {
        // Fetch image with segmentation data
        const imageData = await apiClient.getImageWithSegmentation(finalImageId);
        
        if (!imageData) {
          toast.error('Obrázek nenalezen');
          navigate(`/project/${finalProjectId}`);
          return;
        }
        
        setImageName(imageData.name);
        setImageSrc(imageData.image_url);
        
        // Check for existing segmentation
        if (imageData.segmentation_status === 'completed' && imageData.segmentation) {
          const segResult: SegmentationResult = {
            id: imageData.segmentation.id,
            imageSrc: imageData.image_url,
            polygons: imageData.segmentation.polygons, // Already converted in API client
            imageWidth: imageData.segmentation.imageWidth || 0,
            imageHeight: imageData.segmentation.imageHeight || 0,
            timestamp: new Date(imageData.segmentation.updatedAt)
          };
          
          setSegmentation(segResult);
          
          // Set image dimensions from segmentation data if available and valid
          if (segResult.imageWidth > 0 && segResult.imageHeight > 0) {
            setImageDimensions({
              width: segResult.imageWidth,
              height: segResult.imageHeight
            });
          }
          // If dimensions are 0, we'll rely on the image load handler to detect them
        } else if (imageData.segmentation_status === 'pending' || imageData.segmentation_status === 'failed') {
          // No segmentation available yet, set empty segmentation
          const emptySegmentation: SegmentationResult = {
            imageSrc: imageData.image_url,
            polygons: [],
            imageWidth: 0,
            imageHeight: 0,
            timestamp: new Date()
          };
          setSegmentation(emptySegmentation);
          
          if (imageData.segmentation_status === 'failed') {
            toast.error('Segmentace selhala. Zkuste to prosím znovu.');
          }
        } else {
          // Set empty segmentation for unknown status
          const emptySegmentation: SegmentationResult = {
            imageSrc: imageData.image_url,
            polygons: [],
            imageWidth: 0,
            imageHeight: 0,
            timestamp: new Date()
          };
          setSegmentation(emptySegmentation);
        }
      } catch (error) {
        console.error('Error loading segmentation data:', error);
        toast.error('Nepodařilo se načíst data segmentace');
        
        // Set empty segmentation on error
        const emptySegmentation: SegmentationResult = {
          imageSrc: '',
          polygons: [],
          imageWidth: 0,
          imageHeight: 0,
          timestamp: new Date()
        };
        setSegmentation(emptySegmentation);
      } finally {
        setLoading(false);
      }
    };
    
    fetchData();
  }, [finalProjectId, finalImageId, navigate, onImageChange]);
  
  // Save segmentation
  const handleSave = useCallback(async () => {
    if (!finalImageId || !segmentation) return;
    
    setSaving(true);
    
    try {
      // Convert editor polygons to API format
      const apiPolygons: SegmentationPolygon[] = segmentation.polygons.map(polygon => ({
        id: polygon.id,
        points: polygon.points,
        type: polygon.type || 'external',
        class: polygon.class || 'spheroid',
        // TODO: Calculate parent IDs based on containment if needed
        parentIds: polygon.type === 'internal' ? [] : undefined
      }));
      
      // Save via API
      await apiClient.updateSegmentationResults(finalImageId, apiPolygons);
      
      toast.success('Segmentace uložena');
    } catch (error) {
      console.error('Error saving segmentation:', error);
      toast.error('Nepodařilo se uložit segmentaci');
    } finally {
      setSaving(false);
    }
  }, [finalImageId, segmentation]);
  
  // Navigate to another image
  const navigateToImage = useCallback((direction: 'next' | 'prev' | number) => {
    if (!finalProjectId || projectImages.length === 0) return;
    
    const currentIndex = projectImages.findIndex(img => img.id === finalImageId);
    
    if (currentIndex === -1) return;
    
    let newIndex;
    
    if (typeof direction === 'number') {
      newIndex = direction;
    } else {
      if (direction === 'next') {
        newIndex = currentIndex + 1;
        // Don't wrap around - stop at last image
        if (newIndex >= projectImages.length) return;
      } else {
        newIndex = currentIndex - 1;
        // Don't wrap around - stop at first image
        if (newIndex < 0) return;
      }
    }
    
    const newImageId = projectImages[newIndex].id;
    navigate(`/segmentation/${finalProjectId}/${newImageId}`);
  }, [finalProjectId, finalImageId, projectImages, navigate]);
  
  // Handle image load to capture dimensions from browser if not available from DB
  const handleImageLoad = useCallback((width: number, height: number) => {
    if (!imageDimensions || (imageDimensions.width === 0 && imageDimensions.height === 0)) {
      setImageDimensions({ width, height });
      
      // Also update the segmentation result if it exists and has zero dimensions
      if (segmentation && (segmentation.imageWidth === 0 || segmentation.imageHeight === 0)) {
        setSegmentation(prev => prev ? {
          ...prev,
          imageWidth: width,
          imageHeight: height
        } : null);
      }
    }
  }, [imageDimensions, segmentation, setSegmentation]);
  
  return {
    projectTitle,
    imageName,
    imageSrc,
    segmentation,
    setSegmentation,
    loading,
    saving,
    canvasContainerRef,
    handleSave,
    projectImages,
    navigateToImage,
    imageDimensions,
    handleImageLoad
  };
};
