#!/usr/bin/env bash

echo "🔐 Running STRICT pre-commit validation..."
echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
MAGENTA='\033[0;35m'
NC='\033[0m' # No Color

# Function to print colored output
print_status() {
    echo -e "${BLUE}[$(date '+%H:%M:%S')]${NC} ${CYAN}►${NC} $1"
}

print_success() {
    echo -e "${GREEN}✅ $1${NC}"
}

print_error() {
    echo -e "${RED}❌ $1${NC}"
}

print_warning() {
    echo -e "${YELLOW}⚠️  $1${NC}"
}

print_section() {
    echo ""
    echo -e "${MAGENTA}━━━ $1 ━━━${NC}"
}

# Track failures
FAILURES=""
WARNINGS=""
FAILURE_COUNT=0

# Helper function to track failures
add_failure() {
    FAILURES="$FAILURES\n  • $1"
    FAILURE_COUNT=$((FAILURE_COUNT + 1))
    print_error "$1"
}

# Get all staged files
STAGED_FILES=$(git diff --cached --name-only --diff-filter=ACM)
STAGED_TS_FILES=$(echo "$STAGED_FILES" | grep -E '\.(ts|tsx|js|jsx)$' || true)
STAGED_CSS_FILES=$(echo "$STAGED_FILES" | grep -E '\.(css|scss|less)$' || true)
STAGED_JSON_FILES=$(echo "$STAGED_FILES" | grep -E '\.json$' || true)

print_section "1. CODE FORMATTING"

# Prettier check
print_status "Checking code formatting with Prettier..."
if ! npx prettier --check . > /dev/null 2>&1; then
    add_failure "Code is not properly formatted. Run: npm run format"
else
    print_success "All files are properly formatted"
fi

print_section "2. LINTING"

# ESLint with ZERO tolerance
print_status "Running ESLint with ZERO warnings allowed..."
ESLINT_OUTPUT=$(npx eslint . --ext .js,.jsx,.ts,.tsx --max-warnings 0 2>&1 || true)
if echo "$ESLINT_OUTPUT" | grep -q "error\|warning"; then
    add_failure "ESLint found errors or warnings"
    echo "$ESLINT_OUTPUT" | head -20
    echo "... (truncated, run 'npm run lint' to see all)"
else
    print_success "ESLint passed with no errors or warnings"
fi

# Stylelint for CSS
if [ -n "$STAGED_CSS_FILES" ]; then
    print_status "Running Stylelint on CSS files..."
    if ! npx stylelint "$STAGED_CSS_FILES" > /dev/null 2>&1; then
        add_failure "Stylelint found CSS issues"
    else
        print_success "CSS files passed Stylelint"
    fi
fi

print_section "3. TYPE CHECKING"

# Frontend TypeScript - STRICT mode
print_status "Running STRICT TypeScript checking for frontend..."
if ! npx tsc --noEmit --strict; then
    add_failure "Frontend TypeScript STRICT mode failed"
else
    print_success "Frontend TypeScript STRICT mode passed"
fi

# Backend TypeScript - STRICT mode
print_status "Running STRICT TypeScript checking for backend..."
if ! (cd backend && npx tsc --noEmit --strict); then
    add_failure "Backend TypeScript STRICT mode failed"
else
    print_success "Backend TypeScript STRICT mode passed"
fi

print_section "4. TESTING"

# Run ALL tests (not just related)
print_status "Running ALL unit tests..."
TEST_OUTPUT=$(npm run test -- --run 2>&1 || true)
if echo "$TEST_OUTPUT" | grep -q "FAIL\|Error"; then
    add_failure "Unit tests failed"
    echo "$TEST_OUTPUT" | grep -A 5 "FAIL\|Error" | head -20
else
    print_success "All unit tests passed"
fi

# Check test coverage
print_status "Checking test coverage..."
COVERAGE_OUTPUT=$(npm run test:coverage -- --run 2>&1 || true)
if echo "$COVERAGE_OUTPUT" | grep -q "All files"; then
    COVERAGE_LINE=$(echo "$COVERAGE_OUTPUT" | grep "All files" | head -1)
    COVERAGE_PCT=$(echo "$COVERAGE_LINE" | awk '{print $4}' | sed 's/%//')
    if [ $(echo "$COVERAGE_PCT < 60" | bc -l) = "1" ]; then
        add_failure "Test coverage is below 60% (currently $COVERAGE_PCT%)"
    else
        print_success "Test coverage is $COVERAGE_PCT%"
    fi
fi

print_section "5. SECURITY CHECKS"

# npm audit for vulnerabilities
print_status "Running security audit..."
AUDIT_OUTPUT=$(npm audit --audit-level=moderate 2>&1 || true)
if echo "$AUDIT_OUTPUT" | grep -q "found.*vulnerabilities"; then
    VULNERABILITIES=$(echo "$AUDIT_OUTPUT" | grep "found.*vulnerabilities")
    add_failure "Security vulnerabilities found: $VULNERABILITIES"
else
    print_success "No security vulnerabilities found"
fi

# Check for hardcoded secrets
print_status "Checking for hardcoded secrets..."
SECRET_PATTERNS="(api[_-]?key|apikey|secret|password|pwd|token|auth|credential|private[_-]?key)"
if [ -n "$STAGED_TS_FILES" ]; then
    SECRETS_FOUND=$(echo "$STAGED_TS_FILES" | xargs grep -iE "$SECRET_PATTERNS.*=.*['\"]" 2>/dev/null | grep -v "process.env\|import\|require\|interface\|type\|//" || true)
    if [ -n "$SECRETS_FOUND" ]; then
        add_failure "Possible hardcoded secrets found"
        echo "$SECRETS_FOUND" | head -5
    else
        print_success "No hardcoded secrets detected"
    fi
fi

print_section "6. CODE QUALITY"

# Cyclomatic complexity check
print_status "Checking cyclomatic complexity..."
if [ -n "$STAGED_TS_FILES" ]; then
    COMPLEX_FILES=$(npx eslint $STAGED_TS_FILES --rule 'complexity: ["error", 10]' 2>&1 | grep -c "Cyclomatic complexity" || echo "0")
    if [ "$COMPLEX_FILES" -gt 0 ]; then
        WARNINGS="$WARNINGS\n  • Found $COMPLEX_FILES files with high cyclomatic complexity (>10)"
        print_warning "Found $COMPLEX_FILES files with high complexity"
    else
        print_success "All functions have acceptable complexity"
    fi
fi

# Check for console.log (STRICT - no console.log allowed)
print_status "Checking for console.log statements..."
if [ -n "$STAGED_TS_FILES" ]; then
    CONSOLE_FILES=$(echo "$STAGED_TS_FILES" | xargs grep -l "console\." 2>/dev/null || true)
    if [ -n "$CONSOLE_FILES" ]; then
        add_failure "console statements found - ALL console statements must be removed"
        echo "$CONSOLE_FILES" | xargs grep -n "console\." | head -10
    else
        print_success "No console statements found"
    fi
fi

# Check for debugger statements
print_status "Checking for debugger statements..."
if [ -n "$STAGED_TS_FILES" ]; then
    DEBUGGER_FILES=$(echo "$STAGED_TS_FILES" | xargs grep -l "debugger" 2>/dev/null || true)
    if [ -n "$DEBUGGER_FILES" ]; then
        add_failure "debugger statements found"
        echo "$DEBUGGER_FILES" | xargs grep -n "debugger"
    else
        print_success "No debugger statements found"
    fi
fi

# Check for TODO/FIXME/HACK comments
print_status "Checking for TODO/FIXME/HACK comments..."
if [ -n "$STAGED_TS_FILES" ]; then
    TODO_COUNT=$(echo "$STAGED_TS_FILES" | xargs grep -c "TODO\|FIXME\|HACK\|XXX" 2>/dev/null | grep -v ":0$" | wc -l || echo "0")
    if [ "$TODO_COUNT" -gt 0 ]; then
        add_failure "Found $TODO_COUNT files with TODO/FIXME/HACK comments - resolve before committing"
        echo "$STAGED_TS_FILES" | xargs grep -n "TODO\|FIXME\|HACK\|XXX" 2>/dev/null | head -10
    else
        print_success "No TODO/FIXME/HACK comments found"
    fi
fi

print_section "7. DEPENDENCIES"

# Check for unused dependencies
print_status "Checking for unused dependencies..."
UNUSED_DEPS=$(npx depcheck --json 2>/dev/null | jq -r '.dependencies[]' 2>/dev/null | head -5 || true)
if [ -n "$UNUSED_DEPS" ]; then
    WARNINGS="$WARNINGS\n  • Unused dependencies found: $UNUSED_DEPS"
    print_warning "Found unused dependencies"
fi

# Check package-lock.json consistency
print_status "Checking package-lock.json consistency..."
PACKAGE_MODIFIED=$(echo "$STAGED_FILES" | grep "package\.json$" || true)
if [ -n "$PACKAGE_MODIFIED" ]; then
    PACKAGE_LOCK_MODIFIED=$(echo "$STAGED_FILES" | grep "package-lock\.json$" || true)
    if [ -z "$PACKAGE_LOCK_MODIFIED" ]; then
        add_failure "package.json modified but package-lock.json not updated. Run: npm install"
    else
        print_success "package-lock.json is consistent"
    fi
fi

print_section "8. FILE CHECKS"

# Check for merge conflict markers
print_status "Checking for merge conflict markers..."
CONFLICT_FILES=$(echo "$STAGED_FILES" | xargs grep -l "<<<<<<< \|======= \|>>>>>>> " 2>/dev/null || true)
if [ -n "$CONFLICT_FILES" ]; then
    add_failure "Merge conflict markers found"
    echo "$CONFLICT_FILES"
else
    print_success "No merge conflict markers"
fi

# Check for large files
print_status "Checking for large files..."
LARGE_FILES=$(echo "$STAGED_FILES" | xargs ls -la 2>/dev/null | awk '$5 > 1048576 {print $9 " (" int($5/1048576) "MB)"}' || true)
if [ -n "$LARGE_FILES" ]; then
    add_failure "Large files (>1MB) should not be committed"
    echo "$LARGE_FILES"
else
    print_success "No large files detected"
fi

# Check for binary files
print_status "Checking for binary files..."
BINARY_FILES=$(echo "$STAGED_FILES" | xargs file 2>/dev/null | grep -v "text\|empty" | cut -d: -f1 || true)
if [ -n "$BINARY_FILES" ]; then
    WARNINGS="$WARNINGS\n  • Binary files detected: $BINARY_FILES"
    print_warning "Binary files found (consider using Git LFS)"
fi

print_section "9. IMPORTS & EXPORTS"

# Check for circular dependencies
print_status "Checking for circular dependencies..."
CIRCULAR_DEPS=$(npx madge --circular --extensions ts,tsx,js,jsx src 2>/dev/null || true)
if echo "$CIRCULAR_DEPS" | grep -q "✖"; then
    add_failure "Circular dependencies detected"
    echo "$CIRCULAR_DEPS" | head -20
else
    print_success "No circular dependencies"
fi

# Check for duplicate imports
if [ -n "$STAGED_TS_FILES" ]; then
    print_status "Checking for duplicate imports..."
    for file in $STAGED_TS_FILES; do
        IMPORTS=$(grep "^import" "$file" 2>/dev/null | sed 's/.*from //;s/[";]//g' | sort | uniq -d || true)
        if [ -n "$IMPORTS" ]; then
            add_failure "Duplicate imports in $file: $IMPORTS"
        fi
    done
    [ "$FAILURE_COUNT" -eq 0 ] && print_success "No duplicate imports"
fi

print_section "10. DOCKER VALIDATION"

# Validate Docker files if changed
DOCKER_FILES=$(echo "$STAGED_FILES" | grep -E "Dockerfile|docker-compose.*\.yml$" || true)
if [ -n "$DOCKER_FILES" ]; then
    print_status "Validating Docker configurations..."
    for file in $DOCKER_FILES; do
        if [[ $file == *.yml ]]; then
            if ! docker compose -f "$file" config > /dev/null 2>&1; then
                add_failure "Invalid Docker Compose file: $file"
            fi
        elif [[ $file == *Dockerfile* ]]; then
            if ! docker build -f "$file" --no-cache . --dry-run > /dev/null 2>&1; then
                WARNINGS="$WARNINGS\n  • Potential Dockerfile issues in: $file"
            fi
        fi
    done
    [ "$FAILURE_COUNT" -eq 0 ] && print_success "Docker configurations valid"
fi

print_section "FINAL REPORT"

# Print warnings if any
if [ -n "$WARNINGS" ]; then
    echo ""
    echo -e "${YELLOW}⚠️  WARNINGS:${NC}"
    echo -e "$WARNINGS"
fi

# Print failures if any
if [ "$FAILURE_COUNT" -gt 0 ]; then
    echo ""
    echo -e "${RED}❌ FAILURES:${NC}"
    echo -e "$FAILURES"
    
    echo ""
    echo -e "${RED}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo -e "${RED}COMMIT BLOCKED: $FAILURE_COUNT critical issues must be fixed!${NC}"
    echo -e "${RED}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    
    echo ""
    echo "💡 Quick fixes:"
    echo "  npm run format        - Fix formatting"
    echo "  npm run lint:fix      - Fix linting issues"
    echo "  npm run test          - Run tests"
    echo "  npm audit fix         - Fix security issues"
    echo ""
    echo "🚨 To bypass (EMERGENCY ONLY): git commit --no-verify"
    exit 1
else
    echo ""
    echo -e "${GREEN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo -e "${GREEN}✅ ALL CHECKS PASSED! Safe to commit.${NC}"
    echo -e "${GREEN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo ""
    echo "📋 Validated:"
    echo "  ✓ Code formatting (Prettier)"
    echo "  ✓ Linting (ESLint with 0 warnings)"
    echo "  ✓ TypeScript (STRICT mode)"
    echo "  ✓ Unit tests (all passing)"
    echo "  ✓ Security (no vulnerabilities)"
    echo "  ✓ Code quality (no console/debugger/TODO)"
    echo "  ✓ Dependencies (consistent)"
    echo "  ✓ No circular dependencies"
    echo "  ✓ No merge conflicts"
    echo "  ✓ Docker configs valid"
fi